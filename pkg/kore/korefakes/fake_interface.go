// Code generated by counterfeiter. DO NOT EDIT.
package korefakes

import (
	"context"
	"sync"
	"time"

	"github.com/appvia/kore/pkg/costs"
	"github.com/appvia/kore/pkg/kore"
	"github.com/appvia/kore/pkg/kore/authentication"
	"github.com/appvia/kore/pkg/persistence"
	"github.com/appvia/kore/pkg/persistence/model"
	"github.com/appvia/kore/pkg/store"
)

type FakeInterface struct {
	AccountsStub        func() kore.Accounts
	accountsMutex       sync.RWMutex
	accountsArgsForCall []struct {
	}
	accountsReturns struct {
		result1 kore.Accounts
	}
	accountsReturnsOnCall map[int]struct {
		result1 kore.Accounts
	}
	AlertRulesStub        func() kore.AlertRules
	alertRulesMutex       sync.RWMutex
	alertRulesArgsForCall []struct {
	}
	alertRulesReturns struct {
		result1 kore.AlertRules
	}
	alertRulesReturnsOnCall map[int]struct {
		result1 kore.AlertRules
	}
	AuditStub        func() kore.Audit
	auditMutex       sync.RWMutex
	auditArgsForCall []struct {
	}
	auditReturns struct {
		result1 kore.Audit
	}
	auditReturnsOnCall map[int]struct {
		result1 kore.Audit
	}
	CertificateAuthorityStub        func() []byte
	certificateAuthorityMutex       sync.RWMutex
	certificateAuthorityArgsForCall []struct {
	}
	certificateAuthorityReturns struct {
		result1 []byte
	}
	certificateAuthorityReturnsOnCall map[int]struct {
		result1 []byte
	}
	CertificateAuthorityKeyStub        func() []byte
	certificateAuthorityKeyMutex       sync.RWMutex
	certificateAuthorityKeyArgsForCall []struct {
	}
	certificateAuthorityKeyReturns struct {
		result1 []byte
	}
	certificateAuthorityKeyReturnsOnCall map[int]struct {
		result1 []byte
	}
	ConfigStub        func() *kore.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 *kore.Config
	}
	configReturnsOnCall map[int]struct {
		result1 *kore.Config
	}
	ConfigsStub        func() kore.Configs
	configsMutex       sync.RWMutex
	configsArgsForCall []struct {
	}
	configsReturns struct {
		result1 kore.Configs
	}
	configsReturnsOnCall map[int]struct {
		result1 kore.Configs
	}
	CostsStub        func() costs.Costs
	costsMutex       sync.RWMutex
	costsArgsForCall []struct {
	}
	costsReturns struct {
		result1 costs.Costs
	}
	costsReturnsOnCall map[int]struct {
		result1 costs.Costs
	}
	FeaturesStub        func() kore.KoreFeatures
	featuresMutex       sync.RWMutex
	featuresArgsForCall []struct {
	}
	featuresReturns struct {
		result1 kore.KoreFeatures
	}
	featuresReturnsOnCall map[int]struct {
		result1 kore.KoreFeatures
	}
	GetUserIdentityStub        func(context.Context, string, ...kore.MetaFunc) (authentication.Identity, bool, error)
	getUserIdentityMutex       sync.RWMutex
	getUserIdentityArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []kore.MetaFunc
	}
	getUserIdentityReturns struct {
		result1 authentication.Identity
		result2 bool
		result3 error
	}
	getUserIdentityReturnsOnCall map[int]struct {
		result1 authentication.Identity
		result2 bool
		result3 error
	}
	GetUserIdentityByProviderStub        func(context.Context, string, string) (*model.Identity, bool, error)
	getUserIdentityByProviderMutex       sync.RWMutex
	getUserIdentityByProviderArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getUserIdentityByProviderReturns struct {
		result1 *model.Identity
		result2 bool
		result3 error
	}
	getUserIdentityByProviderReturnsOnCall map[int]struct {
		result1 *model.Identity
		result2 bool
		result3 error
	}
	IDPStub        func() kore.IDP
	iDPMutex       sync.RWMutex
	iDPArgsForCall []struct {
	}
	iDPReturns struct {
		result1 kore.IDP
	}
	iDPReturnsOnCall map[int]struct {
		result1 kore.IDP
	}
	InvitationsStub        func() kore.Invitations
	invitationsMutex       sync.RWMutex
	invitationsArgsForCall []struct {
	}
	invitationsReturns struct {
		result1 kore.Invitations
	}
	invitationsReturnsOnCall map[int]struct {
		result1 kore.Invitations
	}
	PersistStub        func() persistence.Interface
	persistMutex       sync.RWMutex
	persistArgsForCall []struct {
	}
	persistReturns struct {
		result1 persistence.Interface
	}
	persistReturnsOnCall map[int]struct {
		result1 persistence.Interface
	}
	PlanPoliciesStub        func() kore.PlanPolicies
	planPoliciesMutex       sync.RWMutex
	planPoliciesArgsForCall []struct {
	}
	planPoliciesReturns struct {
		result1 kore.PlanPolicies
	}
	planPoliciesReturnsOnCall map[int]struct {
		result1 kore.PlanPolicies
	}
	PlansStub        func() kore.Plans
	plansMutex       sync.RWMutex
	plansArgsForCall []struct {
	}
	plansReturns struct {
		result1 kore.Plans
	}
	plansReturnsOnCall map[int]struct {
		result1 kore.Plans
	}
	SecurityStub        func() kore.Security
	securityMutex       sync.RWMutex
	securityArgsForCall []struct {
	}
	securityReturns struct {
		result1 kore.Security
	}
	securityReturnsOnCall map[int]struct {
		result1 kore.Security
	}
	ServiceKindsStub        func() kore.ServiceKinds
	serviceKindsMutex       sync.RWMutex
	serviceKindsArgsForCall []struct {
	}
	serviceKindsReturns struct {
		result1 kore.ServiceKinds
	}
	serviceKindsReturnsOnCall map[int]struct {
		result1 kore.ServiceKinds
	}
	ServicePlansStub        func() kore.ServicePlans
	servicePlansMutex       sync.RWMutex
	servicePlansArgsForCall []struct {
	}
	servicePlansReturns struct {
		result1 kore.ServicePlans
	}
	servicePlansReturnsOnCall map[int]struct {
		result1 kore.ServicePlans
	}
	ServiceProvidersStub        func() kore.ServiceProviders
	serviceProvidersMutex       sync.RWMutex
	serviceProvidersArgsForCall []struct {
	}
	serviceProvidersReturns struct {
		result1 kore.ServiceProviders
	}
	serviceProvidersReturnsOnCall map[int]struct {
		result1 kore.ServiceProviders
	}
	SignedClientCertificateStub        func(string, string) ([]byte, []byte, error)
	signedClientCertificateMutex       sync.RWMutex
	signedClientCertificateArgsForCall []struct {
		arg1 string
		arg2 string
	}
	signedClientCertificateReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	signedClientCertificateReturnsOnCall map[int]struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	SignedServerCertificateStub        func([]string, time.Duration) ([]byte, []byte, error)
	signedServerCertificateMutex       sync.RWMutex
	signedServerCertificateArgsForCall []struct {
		arg1 []string
		arg2 time.Duration
	}
	signedServerCertificateReturns struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	signedServerCertificateReturnsOnCall map[int]struct {
		result1 []byte
		result2 []byte
		result3 error
	}
	StoreStub        func() store.Store
	storeMutex       sync.RWMutex
	storeArgsForCall []struct {
	}
	storeReturns struct {
		result1 store.Store
	}
	storeReturnsOnCall map[int]struct {
		result1 store.Store
	}
	TeamsStub        func() kore.Teams
	teamsMutex       sync.RWMutex
	teamsArgsForCall []struct {
	}
	teamsReturns struct {
		result1 kore.Teams
	}
	teamsReturnsOnCall map[int]struct {
		result1 kore.Teams
	}
	UsersStub        func() kore.Users
	usersMutex       sync.RWMutex
	usersArgsForCall []struct {
	}
	usersReturns struct {
		result1 kore.Users
	}
	usersReturnsOnCall map[int]struct {
		result1 kore.Users
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInterface) Accounts() kore.Accounts {
	fake.accountsMutex.Lock()
	ret, specificReturn := fake.accountsReturnsOnCall[len(fake.accountsArgsForCall)]
	fake.accountsArgsForCall = append(fake.accountsArgsForCall, struct {
	}{})
	fake.recordInvocation("Accounts", []interface{}{})
	fake.accountsMutex.Unlock()
	if fake.AccountsStub != nil {
		return fake.AccountsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.accountsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) AccountsCallCount() int {
	fake.accountsMutex.RLock()
	defer fake.accountsMutex.RUnlock()
	return len(fake.accountsArgsForCall)
}

func (fake *FakeInterface) AccountsCalls(stub func() kore.Accounts) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = stub
}

func (fake *FakeInterface) AccountsReturns(result1 kore.Accounts) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = nil
	fake.accountsReturns = struct {
		result1 kore.Accounts
	}{result1}
}

func (fake *FakeInterface) AccountsReturnsOnCall(i int, result1 kore.Accounts) {
	fake.accountsMutex.Lock()
	defer fake.accountsMutex.Unlock()
	fake.AccountsStub = nil
	if fake.accountsReturnsOnCall == nil {
		fake.accountsReturnsOnCall = make(map[int]struct {
			result1 kore.Accounts
		})
	}
	fake.accountsReturnsOnCall[i] = struct {
		result1 kore.Accounts
	}{result1}
}

func (fake *FakeInterface) AlertRules() kore.AlertRules {
	fake.alertRulesMutex.Lock()
	ret, specificReturn := fake.alertRulesReturnsOnCall[len(fake.alertRulesArgsForCall)]
	fake.alertRulesArgsForCall = append(fake.alertRulesArgsForCall, struct {
	}{})
	fake.recordInvocation("AlertRules", []interface{}{})
	fake.alertRulesMutex.Unlock()
	if fake.AlertRulesStub != nil {
		return fake.AlertRulesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.alertRulesReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) AlertRulesCallCount() int {
	fake.alertRulesMutex.RLock()
	defer fake.alertRulesMutex.RUnlock()
	return len(fake.alertRulesArgsForCall)
}

func (fake *FakeInterface) AlertRulesCalls(stub func() kore.AlertRules) {
	fake.alertRulesMutex.Lock()
	defer fake.alertRulesMutex.Unlock()
	fake.AlertRulesStub = stub
}

func (fake *FakeInterface) AlertRulesReturns(result1 kore.AlertRules) {
	fake.alertRulesMutex.Lock()
	defer fake.alertRulesMutex.Unlock()
	fake.AlertRulesStub = nil
	fake.alertRulesReturns = struct {
		result1 kore.AlertRules
	}{result1}
}

func (fake *FakeInterface) AlertRulesReturnsOnCall(i int, result1 kore.AlertRules) {
	fake.alertRulesMutex.Lock()
	defer fake.alertRulesMutex.Unlock()
	fake.AlertRulesStub = nil
	if fake.alertRulesReturnsOnCall == nil {
		fake.alertRulesReturnsOnCall = make(map[int]struct {
			result1 kore.AlertRules
		})
	}
	fake.alertRulesReturnsOnCall[i] = struct {
		result1 kore.AlertRules
	}{result1}
}

func (fake *FakeInterface) Audit() kore.Audit {
	fake.auditMutex.Lock()
	ret, specificReturn := fake.auditReturnsOnCall[len(fake.auditArgsForCall)]
	fake.auditArgsForCall = append(fake.auditArgsForCall, struct {
	}{})
	fake.recordInvocation("Audit", []interface{}{})
	fake.auditMutex.Unlock()
	if fake.AuditStub != nil {
		return fake.AuditStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.auditReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) AuditCallCount() int {
	fake.auditMutex.RLock()
	defer fake.auditMutex.RUnlock()
	return len(fake.auditArgsForCall)
}

func (fake *FakeInterface) AuditCalls(stub func() kore.Audit) {
	fake.auditMutex.Lock()
	defer fake.auditMutex.Unlock()
	fake.AuditStub = stub
}

func (fake *FakeInterface) AuditReturns(result1 kore.Audit) {
	fake.auditMutex.Lock()
	defer fake.auditMutex.Unlock()
	fake.AuditStub = nil
	fake.auditReturns = struct {
		result1 kore.Audit
	}{result1}
}

func (fake *FakeInterface) AuditReturnsOnCall(i int, result1 kore.Audit) {
	fake.auditMutex.Lock()
	defer fake.auditMutex.Unlock()
	fake.AuditStub = nil
	if fake.auditReturnsOnCall == nil {
		fake.auditReturnsOnCall = make(map[int]struct {
			result1 kore.Audit
		})
	}
	fake.auditReturnsOnCall[i] = struct {
		result1 kore.Audit
	}{result1}
}

func (fake *FakeInterface) CertificateAuthority() []byte {
	fake.certificateAuthorityMutex.Lock()
	ret, specificReturn := fake.certificateAuthorityReturnsOnCall[len(fake.certificateAuthorityArgsForCall)]
	fake.certificateAuthorityArgsForCall = append(fake.certificateAuthorityArgsForCall, struct {
	}{})
	fake.recordInvocation("CertificateAuthority", []interface{}{})
	fake.certificateAuthorityMutex.Unlock()
	if fake.CertificateAuthorityStub != nil {
		return fake.CertificateAuthorityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.certificateAuthorityReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) CertificateAuthorityCallCount() int {
	fake.certificateAuthorityMutex.RLock()
	defer fake.certificateAuthorityMutex.RUnlock()
	return len(fake.certificateAuthorityArgsForCall)
}

func (fake *FakeInterface) CertificateAuthorityCalls(stub func() []byte) {
	fake.certificateAuthorityMutex.Lock()
	defer fake.certificateAuthorityMutex.Unlock()
	fake.CertificateAuthorityStub = stub
}

func (fake *FakeInterface) CertificateAuthorityReturns(result1 []byte) {
	fake.certificateAuthorityMutex.Lock()
	defer fake.certificateAuthorityMutex.Unlock()
	fake.CertificateAuthorityStub = nil
	fake.certificateAuthorityReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeInterface) CertificateAuthorityReturnsOnCall(i int, result1 []byte) {
	fake.certificateAuthorityMutex.Lock()
	defer fake.certificateAuthorityMutex.Unlock()
	fake.CertificateAuthorityStub = nil
	if fake.certificateAuthorityReturnsOnCall == nil {
		fake.certificateAuthorityReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.certificateAuthorityReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeInterface) CertificateAuthorityKey() []byte {
	fake.certificateAuthorityKeyMutex.Lock()
	ret, specificReturn := fake.certificateAuthorityKeyReturnsOnCall[len(fake.certificateAuthorityKeyArgsForCall)]
	fake.certificateAuthorityKeyArgsForCall = append(fake.certificateAuthorityKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("CertificateAuthorityKey", []interface{}{})
	fake.certificateAuthorityKeyMutex.Unlock()
	if fake.CertificateAuthorityKeyStub != nil {
		return fake.CertificateAuthorityKeyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.certificateAuthorityKeyReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) CertificateAuthorityKeyCallCount() int {
	fake.certificateAuthorityKeyMutex.RLock()
	defer fake.certificateAuthorityKeyMutex.RUnlock()
	return len(fake.certificateAuthorityKeyArgsForCall)
}

func (fake *FakeInterface) CertificateAuthorityKeyCalls(stub func() []byte) {
	fake.certificateAuthorityKeyMutex.Lock()
	defer fake.certificateAuthorityKeyMutex.Unlock()
	fake.CertificateAuthorityKeyStub = stub
}

func (fake *FakeInterface) CertificateAuthorityKeyReturns(result1 []byte) {
	fake.certificateAuthorityKeyMutex.Lock()
	defer fake.certificateAuthorityKeyMutex.Unlock()
	fake.CertificateAuthorityKeyStub = nil
	fake.certificateAuthorityKeyReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeInterface) CertificateAuthorityKeyReturnsOnCall(i int, result1 []byte) {
	fake.certificateAuthorityKeyMutex.Lock()
	defer fake.certificateAuthorityKeyMutex.Unlock()
	fake.CertificateAuthorityKeyStub = nil
	if fake.certificateAuthorityKeyReturnsOnCall == nil {
		fake.certificateAuthorityKeyReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.certificateAuthorityKeyReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeInterface) Config() *kore.Config {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeInterface) ConfigCalls(stub func() *kore.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakeInterface) ConfigReturns(result1 *kore.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 *kore.Config
	}{result1}
}

func (fake *FakeInterface) ConfigReturnsOnCall(i int, result1 *kore.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 *kore.Config
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 *kore.Config
	}{result1}
}

func (fake *FakeInterface) Configs() kore.Configs {
	fake.configsMutex.Lock()
	ret, specificReturn := fake.configsReturnsOnCall[len(fake.configsArgsForCall)]
	fake.configsArgsForCall = append(fake.configsArgsForCall, struct {
	}{})
	fake.recordInvocation("Configs", []interface{}{})
	fake.configsMutex.Unlock()
	if fake.ConfigsStub != nil {
		return fake.ConfigsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) ConfigsCallCount() int {
	fake.configsMutex.RLock()
	defer fake.configsMutex.RUnlock()
	return len(fake.configsArgsForCall)
}

func (fake *FakeInterface) ConfigsCalls(stub func() kore.Configs) {
	fake.configsMutex.Lock()
	defer fake.configsMutex.Unlock()
	fake.ConfigsStub = stub
}

func (fake *FakeInterface) ConfigsReturns(result1 kore.Configs) {
	fake.configsMutex.Lock()
	defer fake.configsMutex.Unlock()
	fake.ConfigsStub = nil
	fake.configsReturns = struct {
		result1 kore.Configs
	}{result1}
}

func (fake *FakeInterface) ConfigsReturnsOnCall(i int, result1 kore.Configs) {
	fake.configsMutex.Lock()
	defer fake.configsMutex.Unlock()
	fake.ConfigsStub = nil
	if fake.configsReturnsOnCall == nil {
		fake.configsReturnsOnCall = make(map[int]struct {
			result1 kore.Configs
		})
	}
	fake.configsReturnsOnCall[i] = struct {
		result1 kore.Configs
	}{result1}
}

func (fake *FakeInterface) Costs() costs.Costs {
	fake.costsMutex.Lock()
	ret, specificReturn := fake.costsReturnsOnCall[len(fake.costsArgsForCall)]
	fake.costsArgsForCall = append(fake.costsArgsForCall, struct {
	}{})
	fake.recordInvocation("Costs", []interface{}{})
	fake.costsMutex.Unlock()
	if fake.CostsStub != nil {
		return fake.CostsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.costsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) CostsCallCount() int {
	fake.costsMutex.RLock()
	defer fake.costsMutex.RUnlock()
	return len(fake.costsArgsForCall)
}

func (fake *FakeInterface) CostsCalls(stub func() costs.Costs) {
	fake.costsMutex.Lock()
	defer fake.costsMutex.Unlock()
	fake.CostsStub = stub
}

func (fake *FakeInterface) CostsReturns(result1 costs.Costs) {
	fake.costsMutex.Lock()
	defer fake.costsMutex.Unlock()
	fake.CostsStub = nil
	fake.costsReturns = struct {
		result1 costs.Costs
	}{result1}
}

func (fake *FakeInterface) CostsReturnsOnCall(i int, result1 costs.Costs) {
	fake.costsMutex.Lock()
	defer fake.costsMutex.Unlock()
	fake.CostsStub = nil
	if fake.costsReturnsOnCall == nil {
		fake.costsReturnsOnCall = make(map[int]struct {
			result1 costs.Costs
		})
	}
	fake.costsReturnsOnCall[i] = struct {
		result1 costs.Costs
	}{result1}
}

func (fake *FakeInterface) Features() kore.KoreFeatures {
	fake.featuresMutex.Lock()
	ret, specificReturn := fake.featuresReturnsOnCall[len(fake.featuresArgsForCall)]
	fake.featuresArgsForCall = append(fake.featuresArgsForCall, struct {
	}{})
	fake.recordInvocation("Features", []interface{}{})
	fake.featuresMutex.Unlock()
	if fake.FeaturesStub != nil {
		return fake.FeaturesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.featuresReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) FeaturesCallCount() int {
	fake.featuresMutex.RLock()
	defer fake.featuresMutex.RUnlock()
	return len(fake.featuresArgsForCall)
}

func (fake *FakeInterface) FeaturesCalls(stub func() kore.KoreFeatures) {
	fake.featuresMutex.Lock()
	defer fake.featuresMutex.Unlock()
	fake.FeaturesStub = stub
}

func (fake *FakeInterface) FeaturesReturns(result1 kore.KoreFeatures) {
	fake.featuresMutex.Lock()
	defer fake.featuresMutex.Unlock()
	fake.FeaturesStub = nil
	fake.featuresReturns = struct {
		result1 kore.KoreFeatures
	}{result1}
}

func (fake *FakeInterface) FeaturesReturnsOnCall(i int, result1 kore.KoreFeatures) {
	fake.featuresMutex.Lock()
	defer fake.featuresMutex.Unlock()
	fake.FeaturesStub = nil
	if fake.featuresReturnsOnCall == nil {
		fake.featuresReturnsOnCall = make(map[int]struct {
			result1 kore.KoreFeatures
		})
	}
	fake.featuresReturnsOnCall[i] = struct {
		result1 kore.KoreFeatures
	}{result1}
}

func (fake *FakeInterface) GetUserIdentity(arg1 context.Context, arg2 string, arg3 ...kore.MetaFunc) (authentication.Identity, bool, error) {
	fake.getUserIdentityMutex.Lock()
	ret, specificReturn := fake.getUserIdentityReturnsOnCall[len(fake.getUserIdentityArgsForCall)]
	fake.getUserIdentityArgsForCall = append(fake.getUserIdentityArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []kore.MetaFunc
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetUserIdentity", []interface{}{arg1, arg2, arg3})
	fake.getUserIdentityMutex.Unlock()
	if fake.GetUserIdentityStub != nil {
		return fake.GetUserIdentityStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getUserIdentityReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeInterface) GetUserIdentityCallCount() int {
	fake.getUserIdentityMutex.RLock()
	defer fake.getUserIdentityMutex.RUnlock()
	return len(fake.getUserIdentityArgsForCall)
}

func (fake *FakeInterface) GetUserIdentityCalls(stub func(context.Context, string, ...kore.MetaFunc) (authentication.Identity, bool, error)) {
	fake.getUserIdentityMutex.Lock()
	defer fake.getUserIdentityMutex.Unlock()
	fake.GetUserIdentityStub = stub
}

func (fake *FakeInterface) GetUserIdentityArgsForCall(i int) (context.Context, string, []kore.MetaFunc) {
	fake.getUserIdentityMutex.RLock()
	defer fake.getUserIdentityMutex.RUnlock()
	argsForCall := fake.getUserIdentityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInterface) GetUserIdentityReturns(result1 authentication.Identity, result2 bool, result3 error) {
	fake.getUserIdentityMutex.Lock()
	defer fake.getUserIdentityMutex.Unlock()
	fake.GetUserIdentityStub = nil
	fake.getUserIdentityReturns = struct {
		result1 authentication.Identity
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetUserIdentityReturnsOnCall(i int, result1 authentication.Identity, result2 bool, result3 error) {
	fake.getUserIdentityMutex.Lock()
	defer fake.getUserIdentityMutex.Unlock()
	fake.GetUserIdentityStub = nil
	if fake.getUserIdentityReturnsOnCall == nil {
		fake.getUserIdentityReturnsOnCall = make(map[int]struct {
			result1 authentication.Identity
			result2 bool
			result3 error
		})
	}
	fake.getUserIdentityReturnsOnCall[i] = struct {
		result1 authentication.Identity
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetUserIdentityByProvider(arg1 context.Context, arg2 string, arg3 string) (*model.Identity, bool, error) {
	fake.getUserIdentityByProviderMutex.Lock()
	ret, specificReturn := fake.getUserIdentityByProviderReturnsOnCall[len(fake.getUserIdentityByProviderArgsForCall)]
	fake.getUserIdentityByProviderArgsForCall = append(fake.getUserIdentityByProviderArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetUserIdentityByProvider", []interface{}{arg1, arg2, arg3})
	fake.getUserIdentityByProviderMutex.Unlock()
	if fake.GetUserIdentityByProviderStub != nil {
		return fake.GetUserIdentityByProviderStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getUserIdentityByProviderReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeInterface) GetUserIdentityByProviderCallCount() int {
	fake.getUserIdentityByProviderMutex.RLock()
	defer fake.getUserIdentityByProviderMutex.RUnlock()
	return len(fake.getUserIdentityByProviderArgsForCall)
}

func (fake *FakeInterface) GetUserIdentityByProviderCalls(stub func(context.Context, string, string) (*model.Identity, bool, error)) {
	fake.getUserIdentityByProviderMutex.Lock()
	defer fake.getUserIdentityByProviderMutex.Unlock()
	fake.GetUserIdentityByProviderStub = stub
}

func (fake *FakeInterface) GetUserIdentityByProviderArgsForCall(i int) (context.Context, string, string) {
	fake.getUserIdentityByProviderMutex.RLock()
	defer fake.getUserIdentityByProviderMutex.RUnlock()
	argsForCall := fake.getUserIdentityByProviderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInterface) GetUserIdentityByProviderReturns(result1 *model.Identity, result2 bool, result3 error) {
	fake.getUserIdentityByProviderMutex.Lock()
	defer fake.getUserIdentityByProviderMutex.Unlock()
	fake.GetUserIdentityByProviderStub = nil
	fake.getUserIdentityByProviderReturns = struct {
		result1 *model.Identity
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetUserIdentityByProviderReturnsOnCall(i int, result1 *model.Identity, result2 bool, result3 error) {
	fake.getUserIdentityByProviderMutex.Lock()
	defer fake.getUserIdentityByProviderMutex.Unlock()
	fake.GetUserIdentityByProviderStub = nil
	if fake.getUserIdentityByProviderReturnsOnCall == nil {
		fake.getUserIdentityByProviderReturnsOnCall = make(map[int]struct {
			result1 *model.Identity
			result2 bool
			result3 error
		})
	}
	fake.getUserIdentityByProviderReturnsOnCall[i] = struct {
		result1 *model.Identity
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) IDP() kore.IDP {
	fake.iDPMutex.Lock()
	ret, specificReturn := fake.iDPReturnsOnCall[len(fake.iDPArgsForCall)]
	fake.iDPArgsForCall = append(fake.iDPArgsForCall, struct {
	}{})
	fake.recordInvocation("IDP", []interface{}{})
	fake.iDPMutex.Unlock()
	if fake.IDPStub != nil {
		return fake.IDPStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDPReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) IDPCallCount() int {
	fake.iDPMutex.RLock()
	defer fake.iDPMutex.RUnlock()
	return len(fake.iDPArgsForCall)
}

func (fake *FakeInterface) IDPCalls(stub func() kore.IDP) {
	fake.iDPMutex.Lock()
	defer fake.iDPMutex.Unlock()
	fake.IDPStub = stub
}

func (fake *FakeInterface) IDPReturns(result1 kore.IDP) {
	fake.iDPMutex.Lock()
	defer fake.iDPMutex.Unlock()
	fake.IDPStub = nil
	fake.iDPReturns = struct {
		result1 kore.IDP
	}{result1}
}

func (fake *FakeInterface) IDPReturnsOnCall(i int, result1 kore.IDP) {
	fake.iDPMutex.Lock()
	defer fake.iDPMutex.Unlock()
	fake.IDPStub = nil
	if fake.iDPReturnsOnCall == nil {
		fake.iDPReturnsOnCall = make(map[int]struct {
			result1 kore.IDP
		})
	}
	fake.iDPReturnsOnCall[i] = struct {
		result1 kore.IDP
	}{result1}
}

func (fake *FakeInterface) Invitations() kore.Invitations {
	fake.invitationsMutex.Lock()
	ret, specificReturn := fake.invitationsReturnsOnCall[len(fake.invitationsArgsForCall)]
	fake.invitationsArgsForCall = append(fake.invitationsArgsForCall, struct {
	}{})
	fake.recordInvocation("Invitations", []interface{}{})
	fake.invitationsMutex.Unlock()
	if fake.InvitationsStub != nil {
		return fake.InvitationsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.invitationsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) InvitationsCallCount() int {
	fake.invitationsMutex.RLock()
	defer fake.invitationsMutex.RUnlock()
	return len(fake.invitationsArgsForCall)
}

func (fake *FakeInterface) InvitationsCalls(stub func() kore.Invitations) {
	fake.invitationsMutex.Lock()
	defer fake.invitationsMutex.Unlock()
	fake.InvitationsStub = stub
}

func (fake *FakeInterface) InvitationsReturns(result1 kore.Invitations) {
	fake.invitationsMutex.Lock()
	defer fake.invitationsMutex.Unlock()
	fake.InvitationsStub = nil
	fake.invitationsReturns = struct {
		result1 kore.Invitations
	}{result1}
}

func (fake *FakeInterface) InvitationsReturnsOnCall(i int, result1 kore.Invitations) {
	fake.invitationsMutex.Lock()
	defer fake.invitationsMutex.Unlock()
	fake.InvitationsStub = nil
	if fake.invitationsReturnsOnCall == nil {
		fake.invitationsReturnsOnCall = make(map[int]struct {
			result1 kore.Invitations
		})
	}
	fake.invitationsReturnsOnCall[i] = struct {
		result1 kore.Invitations
	}{result1}
}

func (fake *FakeInterface) Persist() persistence.Interface {
	fake.persistMutex.Lock()
	ret, specificReturn := fake.persistReturnsOnCall[len(fake.persistArgsForCall)]
	fake.persistArgsForCall = append(fake.persistArgsForCall, struct {
	}{})
	fake.recordInvocation("Persist", []interface{}{})
	fake.persistMutex.Unlock()
	if fake.PersistStub != nil {
		return fake.PersistStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.persistReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) PersistCallCount() int {
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	return len(fake.persistArgsForCall)
}

func (fake *FakeInterface) PersistCalls(stub func() persistence.Interface) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = stub
}

func (fake *FakeInterface) PersistReturns(result1 persistence.Interface) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = nil
	fake.persistReturns = struct {
		result1 persistence.Interface
	}{result1}
}

func (fake *FakeInterface) PersistReturnsOnCall(i int, result1 persistence.Interface) {
	fake.persistMutex.Lock()
	defer fake.persistMutex.Unlock()
	fake.PersistStub = nil
	if fake.persistReturnsOnCall == nil {
		fake.persistReturnsOnCall = make(map[int]struct {
			result1 persistence.Interface
		})
	}
	fake.persistReturnsOnCall[i] = struct {
		result1 persistence.Interface
	}{result1}
}

func (fake *FakeInterface) PlanPolicies() kore.PlanPolicies {
	fake.planPoliciesMutex.Lock()
	ret, specificReturn := fake.planPoliciesReturnsOnCall[len(fake.planPoliciesArgsForCall)]
	fake.planPoliciesArgsForCall = append(fake.planPoliciesArgsForCall, struct {
	}{})
	fake.recordInvocation("PlanPolicies", []interface{}{})
	fake.planPoliciesMutex.Unlock()
	if fake.PlanPoliciesStub != nil {
		return fake.PlanPoliciesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.planPoliciesReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) PlanPoliciesCallCount() int {
	fake.planPoliciesMutex.RLock()
	defer fake.planPoliciesMutex.RUnlock()
	return len(fake.planPoliciesArgsForCall)
}

func (fake *FakeInterface) PlanPoliciesCalls(stub func() kore.PlanPolicies) {
	fake.planPoliciesMutex.Lock()
	defer fake.planPoliciesMutex.Unlock()
	fake.PlanPoliciesStub = stub
}

func (fake *FakeInterface) PlanPoliciesReturns(result1 kore.PlanPolicies) {
	fake.planPoliciesMutex.Lock()
	defer fake.planPoliciesMutex.Unlock()
	fake.PlanPoliciesStub = nil
	fake.planPoliciesReturns = struct {
		result1 kore.PlanPolicies
	}{result1}
}

func (fake *FakeInterface) PlanPoliciesReturnsOnCall(i int, result1 kore.PlanPolicies) {
	fake.planPoliciesMutex.Lock()
	defer fake.planPoliciesMutex.Unlock()
	fake.PlanPoliciesStub = nil
	if fake.planPoliciesReturnsOnCall == nil {
		fake.planPoliciesReturnsOnCall = make(map[int]struct {
			result1 kore.PlanPolicies
		})
	}
	fake.planPoliciesReturnsOnCall[i] = struct {
		result1 kore.PlanPolicies
	}{result1}
}

func (fake *FakeInterface) Plans() kore.Plans {
	fake.plansMutex.Lock()
	ret, specificReturn := fake.plansReturnsOnCall[len(fake.plansArgsForCall)]
	fake.plansArgsForCall = append(fake.plansArgsForCall, struct {
	}{})
	fake.recordInvocation("Plans", []interface{}{})
	fake.plansMutex.Unlock()
	if fake.PlansStub != nil {
		return fake.PlansStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.plansReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) PlansCallCount() int {
	fake.plansMutex.RLock()
	defer fake.plansMutex.RUnlock()
	return len(fake.plansArgsForCall)
}

func (fake *FakeInterface) PlansCalls(stub func() kore.Plans) {
	fake.plansMutex.Lock()
	defer fake.plansMutex.Unlock()
	fake.PlansStub = stub
}

func (fake *FakeInterface) PlansReturns(result1 kore.Plans) {
	fake.plansMutex.Lock()
	defer fake.plansMutex.Unlock()
	fake.PlansStub = nil
	fake.plansReturns = struct {
		result1 kore.Plans
	}{result1}
}

func (fake *FakeInterface) PlansReturnsOnCall(i int, result1 kore.Plans) {
	fake.plansMutex.Lock()
	defer fake.plansMutex.Unlock()
	fake.PlansStub = nil
	if fake.plansReturnsOnCall == nil {
		fake.plansReturnsOnCall = make(map[int]struct {
			result1 kore.Plans
		})
	}
	fake.plansReturnsOnCall[i] = struct {
		result1 kore.Plans
	}{result1}
}

func (fake *FakeInterface) Security() kore.Security {
	fake.securityMutex.Lock()
	ret, specificReturn := fake.securityReturnsOnCall[len(fake.securityArgsForCall)]
	fake.securityArgsForCall = append(fake.securityArgsForCall, struct {
	}{})
	fake.recordInvocation("Security", []interface{}{})
	fake.securityMutex.Unlock()
	if fake.SecurityStub != nil {
		return fake.SecurityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.securityReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) SecurityCallCount() int {
	fake.securityMutex.RLock()
	defer fake.securityMutex.RUnlock()
	return len(fake.securityArgsForCall)
}

func (fake *FakeInterface) SecurityCalls(stub func() kore.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = stub
}

func (fake *FakeInterface) SecurityReturns(result1 kore.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = nil
	fake.securityReturns = struct {
		result1 kore.Security
	}{result1}
}

func (fake *FakeInterface) SecurityReturnsOnCall(i int, result1 kore.Security) {
	fake.securityMutex.Lock()
	defer fake.securityMutex.Unlock()
	fake.SecurityStub = nil
	if fake.securityReturnsOnCall == nil {
		fake.securityReturnsOnCall = make(map[int]struct {
			result1 kore.Security
		})
	}
	fake.securityReturnsOnCall[i] = struct {
		result1 kore.Security
	}{result1}
}

func (fake *FakeInterface) ServiceKinds() kore.ServiceKinds {
	fake.serviceKindsMutex.Lock()
	ret, specificReturn := fake.serviceKindsReturnsOnCall[len(fake.serviceKindsArgsForCall)]
	fake.serviceKindsArgsForCall = append(fake.serviceKindsArgsForCall, struct {
	}{})
	fake.recordInvocation("ServiceKinds", []interface{}{})
	fake.serviceKindsMutex.Unlock()
	if fake.ServiceKindsStub != nil {
		return fake.ServiceKindsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.serviceKindsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) ServiceKindsCallCount() int {
	fake.serviceKindsMutex.RLock()
	defer fake.serviceKindsMutex.RUnlock()
	return len(fake.serviceKindsArgsForCall)
}

func (fake *FakeInterface) ServiceKindsCalls(stub func() kore.ServiceKinds) {
	fake.serviceKindsMutex.Lock()
	defer fake.serviceKindsMutex.Unlock()
	fake.ServiceKindsStub = stub
}

func (fake *FakeInterface) ServiceKindsReturns(result1 kore.ServiceKinds) {
	fake.serviceKindsMutex.Lock()
	defer fake.serviceKindsMutex.Unlock()
	fake.ServiceKindsStub = nil
	fake.serviceKindsReturns = struct {
		result1 kore.ServiceKinds
	}{result1}
}

func (fake *FakeInterface) ServiceKindsReturnsOnCall(i int, result1 kore.ServiceKinds) {
	fake.serviceKindsMutex.Lock()
	defer fake.serviceKindsMutex.Unlock()
	fake.ServiceKindsStub = nil
	if fake.serviceKindsReturnsOnCall == nil {
		fake.serviceKindsReturnsOnCall = make(map[int]struct {
			result1 kore.ServiceKinds
		})
	}
	fake.serviceKindsReturnsOnCall[i] = struct {
		result1 kore.ServiceKinds
	}{result1}
}

func (fake *FakeInterface) ServicePlans() kore.ServicePlans {
	fake.servicePlansMutex.Lock()
	ret, specificReturn := fake.servicePlansReturnsOnCall[len(fake.servicePlansArgsForCall)]
	fake.servicePlansArgsForCall = append(fake.servicePlansArgsForCall, struct {
	}{})
	fake.recordInvocation("ServicePlans", []interface{}{})
	fake.servicePlansMutex.Unlock()
	if fake.ServicePlansStub != nil {
		return fake.ServicePlansStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.servicePlansReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) ServicePlansCallCount() int {
	fake.servicePlansMutex.RLock()
	defer fake.servicePlansMutex.RUnlock()
	return len(fake.servicePlansArgsForCall)
}

func (fake *FakeInterface) ServicePlansCalls(stub func() kore.ServicePlans) {
	fake.servicePlansMutex.Lock()
	defer fake.servicePlansMutex.Unlock()
	fake.ServicePlansStub = stub
}

func (fake *FakeInterface) ServicePlansReturns(result1 kore.ServicePlans) {
	fake.servicePlansMutex.Lock()
	defer fake.servicePlansMutex.Unlock()
	fake.ServicePlansStub = nil
	fake.servicePlansReturns = struct {
		result1 kore.ServicePlans
	}{result1}
}

func (fake *FakeInterface) ServicePlansReturnsOnCall(i int, result1 kore.ServicePlans) {
	fake.servicePlansMutex.Lock()
	defer fake.servicePlansMutex.Unlock()
	fake.ServicePlansStub = nil
	if fake.servicePlansReturnsOnCall == nil {
		fake.servicePlansReturnsOnCall = make(map[int]struct {
			result1 kore.ServicePlans
		})
	}
	fake.servicePlansReturnsOnCall[i] = struct {
		result1 kore.ServicePlans
	}{result1}
}

func (fake *FakeInterface) ServiceProviders() kore.ServiceProviders {
	fake.serviceProvidersMutex.Lock()
	ret, specificReturn := fake.serviceProvidersReturnsOnCall[len(fake.serviceProvidersArgsForCall)]
	fake.serviceProvidersArgsForCall = append(fake.serviceProvidersArgsForCall, struct {
	}{})
	fake.recordInvocation("ServiceProviders", []interface{}{})
	fake.serviceProvidersMutex.Unlock()
	if fake.ServiceProvidersStub != nil {
		return fake.ServiceProvidersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.serviceProvidersReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) ServiceProvidersCallCount() int {
	fake.serviceProvidersMutex.RLock()
	defer fake.serviceProvidersMutex.RUnlock()
	return len(fake.serviceProvidersArgsForCall)
}

func (fake *FakeInterface) ServiceProvidersCalls(stub func() kore.ServiceProviders) {
	fake.serviceProvidersMutex.Lock()
	defer fake.serviceProvidersMutex.Unlock()
	fake.ServiceProvidersStub = stub
}

func (fake *FakeInterface) ServiceProvidersReturns(result1 kore.ServiceProviders) {
	fake.serviceProvidersMutex.Lock()
	defer fake.serviceProvidersMutex.Unlock()
	fake.ServiceProvidersStub = nil
	fake.serviceProvidersReturns = struct {
		result1 kore.ServiceProviders
	}{result1}
}

func (fake *FakeInterface) ServiceProvidersReturnsOnCall(i int, result1 kore.ServiceProviders) {
	fake.serviceProvidersMutex.Lock()
	defer fake.serviceProvidersMutex.Unlock()
	fake.ServiceProvidersStub = nil
	if fake.serviceProvidersReturnsOnCall == nil {
		fake.serviceProvidersReturnsOnCall = make(map[int]struct {
			result1 kore.ServiceProviders
		})
	}
	fake.serviceProvidersReturnsOnCall[i] = struct {
		result1 kore.ServiceProviders
	}{result1}
}

func (fake *FakeInterface) SignedClientCertificate(arg1 string, arg2 string) ([]byte, []byte, error) {
	fake.signedClientCertificateMutex.Lock()
	ret, specificReturn := fake.signedClientCertificateReturnsOnCall[len(fake.signedClientCertificateArgsForCall)]
	fake.signedClientCertificateArgsForCall = append(fake.signedClientCertificateArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SignedClientCertificate", []interface{}{arg1, arg2})
	fake.signedClientCertificateMutex.Unlock()
	if fake.SignedClientCertificateStub != nil {
		return fake.SignedClientCertificateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.signedClientCertificateReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeInterface) SignedClientCertificateCallCount() int {
	fake.signedClientCertificateMutex.RLock()
	defer fake.signedClientCertificateMutex.RUnlock()
	return len(fake.signedClientCertificateArgsForCall)
}

func (fake *FakeInterface) SignedClientCertificateCalls(stub func(string, string) ([]byte, []byte, error)) {
	fake.signedClientCertificateMutex.Lock()
	defer fake.signedClientCertificateMutex.Unlock()
	fake.SignedClientCertificateStub = stub
}

func (fake *FakeInterface) SignedClientCertificateArgsForCall(i int) (string, string) {
	fake.signedClientCertificateMutex.RLock()
	defer fake.signedClientCertificateMutex.RUnlock()
	argsForCall := fake.signedClientCertificateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInterface) SignedClientCertificateReturns(result1 []byte, result2 []byte, result3 error) {
	fake.signedClientCertificateMutex.Lock()
	defer fake.signedClientCertificateMutex.Unlock()
	fake.SignedClientCertificateStub = nil
	fake.signedClientCertificateReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) SignedClientCertificateReturnsOnCall(i int, result1 []byte, result2 []byte, result3 error) {
	fake.signedClientCertificateMutex.Lock()
	defer fake.signedClientCertificateMutex.Unlock()
	fake.SignedClientCertificateStub = nil
	if fake.signedClientCertificateReturnsOnCall == nil {
		fake.signedClientCertificateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 []byte
			result3 error
		})
	}
	fake.signedClientCertificateReturnsOnCall[i] = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) SignedServerCertificate(arg1 []string, arg2 time.Duration) ([]byte, []byte, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.signedServerCertificateMutex.Lock()
	ret, specificReturn := fake.signedServerCertificateReturnsOnCall[len(fake.signedServerCertificateArgsForCall)]
	fake.signedServerCertificateArgsForCall = append(fake.signedServerCertificateArgsForCall, struct {
		arg1 []string
		arg2 time.Duration
	}{arg1Copy, arg2})
	fake.recordInvocation("SignedServerCertificate", []interface{}{arg1Copy, arg2})
	fake.signedServerCertificateMutex.Unlock()
	if fake.SignedServerCertificateStub != nil {
		return fake.SignedServerCertificateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.signedServerCertificateReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeInterface) SignedServerCertificateCallCount() int {
	fake.signedServerCertificateMutex.RLock()
	defer fake.signedServerCertificateMutex.RUnlock()
	return len(fake.signedServerCertificateArgsForCall)
}

func (fake *FakeInterface) SignedServerCertificateCalls(stub func([]string, time.Duration) ([]byte, []byte, error)) {
	fake.signedServerCertificateMutex.Lock()
	defer fake.signedServerCertificateMutex.Unlock()
	fake.SignedServerCertificateStub = stub
}

func (fake *FakeInterface) SignedServerCertificateArgsForCall(i int) ([]string, time.Duration) {
	fake.signedServerCertificateMutex.RLock()
	defer fake.signedServerCertificateMutex.RUnlock()
	argsForCall := fake.signedServerCertificateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInterface) SignedServerCertificateReturns(result1 []byte, result2 []byte, result3 error) {
	fake.signedServerCertificateMutex.Lock()
	defer fake.signedServerCertificateMutex.Unlock()
	fake.SignedServerCertificateStub = nil
	fake.signedServerCertificateReturns = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) SignedServerCertificateReturnsOnCall(i int, result1 []byte, result2 []byte, result3 error) {
	fake.signedServerCertificateMutex.Lock()
	defer fake.signedServerCertificateMutex.Unlock()
	fake.SignedServerCertificateStub = nil
	if fake.signedServerCertificateReturnsOnCall == nil {
		fake.signedServerCertificateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 []byte
			result3 error
		})
	}
	fake.signedServerCertificateReturnsOnCall[i] = struct {
		result1 []byte
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) Store() store.Store {
	fake.storeMutex.Lock()
	ret, specificReturn := fake.storeReturnsOnCall[len(fake.storeArgsForCall)]
	fake.storeArgsForCall = append(fake.storeArgsForCall, struct {
	}{})
	fake.recordInvocation("Store", []interface{}{})
	fake.storeMutex.Unlock()
	if fake.StoreStub != nil {
		return fake.StoreStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.storeReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) StoreCallCount() int {
	fake.storeMutex.RLock()
	defer fake.storeMutex.RUnlock()
	return len(fake.storeArgsForCall)
}

func (fake *FakeInterface) StoreCalls(stub func() store.Store) {
	fake.storeMutex.Lock()
	defer fake.storeMutex.Unlock()
	fake.StoreStub = stub
}

func (fake *FakeInterface) StoreReturns(result1 store.Store) {
	fake.storeMutex.Lock()
	defer fake.storeMutex.Unlock()
	fake.StoreStub = nil
	fake.storeReturns = struct {
		result1 store.Store
	}{result1}
}

func (fake *FakeInterface) StoreReturnsOnCall(i int, result1 store.Store) {
	fake.storeMutex.Lock()
	defer fake.storeMutex.Unlock()
	fake.StoreStub = nil
	if fake.storeReturnsOnCall == nil {
		fake.storeReturnsOnCall = make(map[int]struct {
			result1 store.Store
		})
	}
	fake.storeReturnsOnCall[i] = struct {
		result1 store.Store
	}{result1}
}

func (fake *FakeInterface) Teams() kore.Teams {
	fake.teamsMutex.Lock()
	ret, specificReturn := fake.teamsReturnsOnCall[len(fake.teamsArgsForCall)]
	fake.teamsArgsForCall = append(fake.teamsArgsForCall, struct {
	}{})
	fake.recordInvocation("Teams", []interface{}{})
	fake.teamsMutex.Unlock()
	if fake.TeamsStub != nil {
		return fake.TeamsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamsReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) TeamsCallCount() int {
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	return len(fake.teamsArgsForCall)
}

func (fake *FakeInterface) TeamsCalls(stub func() kore.Teams) {
	fake.teamsMutex.Lock()
	defer fake.teamsMutex.Unlock()
	fake.TeamsStub = stub
}

func (fake *FakeInterface) TeamsReturns(result1 kore.Teams) {
	fake.teamsMutex.Lock()
	defer fake.teamsMutex.Unlock()
	fake.TeamsStub = nil
	fake.teamsReturns = struct {
		result1 kore.Teams
	}{result1}
}

func (fake *FakeInterface) TeamsReturnsOnCall(i int, result1 kore.Teams) {
	fake.teamsMutex.Lock()
	defer fake.teamsMutex.Unlock()
	fake.TeamsStub = nil
	if fake.teamsReturnsOnCall == nil {
		fake.teamsReturnsOnCall = make(map[int]struct {
			result1 kore.Teams
		})
	}
	fake.teamsReturnsOnCall[i] = struct {
		result1 kore.Teams
	}{result1}
}

func (fake *FakeInterface) Users() kore.Users {
	fake.usersMutex.Lock()
	ret, specificReturn := fake.usersReturnsOnCall[len(fake.usersArgsForCall)]
	fake.usersArgsForCall = append(fake.usersArgsForCall, struct {
	}{})
	fake.recordInvocation("Users", []interface{}{})
	fake.usersMutex.Unlock()
	if fake.UsersStub != nil {
		return fake.UsersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.usersReturns
	return fakeReturns.result1
}

func (fake *FakeInterface) UsersCallCount() int {
	fake.usersMutex.RLock()
	defer fake.usersMutex.RUnlock()
	return len(fake.usersArgsForCall)
}

func (fake *FakeInterface) UsersCalls(stub func() kore.Users) {
	fake.usersMutex.Lock()
	defer fake.usersMutex.Unlock()
	fake.UsersStub = stub
}

func (fake *FakeInterface) UsersReturns(result1 kore.Users) {
	fake.usersMutex.Lock()
	defer fake.usersMutex.Unlock()
	fake.UsersStub = nil
	fake.usersReturns = struct {
		result1 kore.Users
	}{result1}
}

func (fake *FakeInterface) UsersReturnsOnCall(i int, result1 kore.Users) {
	fake.usersMutex.Lock()
	defer fake.usersMutex.Unlock()
	fake.UsersStub = nil
	if fake.usersReturnsOnCall == nil {
		fake.usersReturnsOnCall = make(map[int]struct {
			result1 kore.Users
		})
	}
	fake.usersReturnsOnCall[i] = struct {
		result1 kore.Users
	}{result1}
}

func (fake *FakeInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.accountsMutex.RLock()
	defer fake.accountsMutex.RUnlock()
	fake.alertRulesMutex.RLock()
	defer fake.alertRulesMutex.RUnlock()
	fake.auditMutex.RLock()
	defer fake.auditMutex.RUnlock()
	fake.certificateAuthorityMutex.RLock()
	defer fake.certificateAuthorityMutex.RUnlock()
	fake.certificateAuthorityKeyMutex.RLock()
	defer fake.certificateAuthorityKeyMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.configsMutex.RLock()
	defer fake.configsMutex.RUnlock()
	fake.costsMutex.RLock()
	defer fake.costsMutex.RUnlock()
	fake.featuresMutex.RLock()
	defer fake.featuresMutex.RUnlock()
	fake.getUserIdentityMutex.RLock()
	defer fake.getUserIdentityMutex.RUnlock()
	fake.getUserIdentityByProviderMutex.RLock()
	defer fake.getUserIdentityByProviderMutex.RUnlock()
	fake.iDPMutex.RLock()
	defer fake.iDPMutex.RUnlock()
	fake.invitationsMutex.RLock()
	defer fake.invitationsMutex.RUnlock()
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	fake.planPoliciesMutex.RLock()
	defer fake.planPoliciesMutex.RUnlock()
	fake.plansMutex.RLock()
	defer fake.plansMutex.RUnlock()
	fake.securityMutex.RLock()
	defer fake.securityMutex.RUnlock()
	fake.serviceKindsMutex.RLock()
	defer fake.serviceKindsMutex.RUnlock()
	fake.servicePlansMutex.RLock()
	defer fake.servicePlansMutex.RUnlock()
	fake.serviceProvidersMutex.RLock()
	defer fake.serviceProvidersMutex.RUnlock()
	fake.signedClientCertificateMutex.RLock()
	defer fake.signedClientCertificateMutex.RUnlock()
	fake.signedServerCertificateMutex.RLock()
	defer fake.signedServerCertificateMutex.RUnlock()
	fake.storeMutex.RLock()
	defer fake.storeMutex.RUnlock()
	fake.teamsMutex.RLock()
	defer fake.teamsMutex.RUnlock()
	fake.usersMutex.RLock()
	defer fake.usersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kore.Interface = new(FakeInterface)
